"""
Module to simulate the output of a PhotoVoltaic generator.
"""

import csv
import json
import random
import os.path
from datetime import datetime

import numpy as np
from pv_simulator.messenger_service import MessengerService


def linear_function(a, b, x):
    """
    A generic lineal function.
    a coefficient is slope.
    b is intercept.
    """
    return a*x + b

def quadratic_function(a, b, c, x):
    """
    A generic quadratic function.
    a coefficient is parabola branches amplitude.
    b is displacement of pivot point over x=y linear function.
    c is Y axis displacement.
    """
    return a*np.power(x, 2) + b*x + c

def head_curve(x):
    """First segment of curve function."""
    a = 160
    b = -880
    return linear_function(a, b, x)

def tail_curve(x):
    """Last segment of curve function."""
    a = -100
    b = 2100
    return linear_function(a, b, x)

def center_curve(x):
    """Main segment of curve function."""
    a = -82.87
    b = 2295
    c = - 12660
    return quadratic_function(a, b, c, x)

def curve(time):
    """
    A curve that simulates a PV output.
    Is defined by segments, and tries to emulate the PV energy
    produced by a solar panel.
    """
    value_to_especialize = time.hour + time.minute/60
    if 5.5 <= time.hour < 8:
        value = head_curve(value_to_especialize)
    elif 8 <= time.hour < 20:
        value = center_curve(value_to_especialize)
    elif 20 <= time.hour < 21:
        value = tail_curve(value_to_especialize)
    else:
        value = 0
    return value * random.randrange(85, 100)/100 # The product with a random value emulates the noise

class Consumer:
    """The data consumer from the meter, also outputs the data to csv."""
    def start(self):
        """Starts the PV panel queue."""
        self.broker.consume_measurements(self.process_measurement)

    def setup_broker(self, queue_name='meter', broker_hostname='broker',
                     broker_port=5672, broker_user='guest', broker_passwd='guest'):
        """Set up the messenger service and its queue."""
        self.broker = MessengerService(queue_name, broker_hostname, broker_port,
                                       broker_user, broker_passwd)

    def process_measurement(self, _ch, _method, _properties, body):
        """The callback function executed when a new payload arrives."""
        message_data = json.loads(body)
        collected_measurements = {
            'date': message_data['date'],
            'meter_measurement': message_data['measurement'],
            'pv_raw_output': self.get_pv_raw_output_power(message_data['date']),
            'total_output': self.get_pv_output_power(body),
        }
        print(" [x] Received %r" % body)
        self.persist_measurements(collected_measurements)

    def persist_measurements(self, measurements_dict):
        """Save the measurements into a csv file."""
        filename = "export/measurements_results.csv"
        file_exist = os.path.isfile(filename)
        headers = measurements_dict.keys()
        if file_exist:
            with open(filename, mode='a') as csv_file:
                writer = csv.DictWriter(csv_file, fieldnames=headers)
                writer.writerow(measurements_dict)
        else:
            with open(filename, mode='w') as csv_file:
                writer = csv.DictWriter(csv_file, fieldnames=headers)
                writer.writeheader()
                writer.writerow(measurements_dict)

    def get_pv_output_power(self, payload):
        """Returns the resulting output power of the whole system."""
        message_data = json.loads(payload)
        raw_output = self.get_pv_raw_output_power(message_data['date'])
        total_output = raw_output - message_data['measurement']
        return total_output

    def get_pv_raw_output_power(self, date):
        """Returns the output power generated by PV panel at a given time."""
        interval_time = datetime.fromisoformat(date)
        return curve(interval_time)

def main():
    """Entry point for consumer."""
    consumer = Consumer()
    consumer.setup_broker()
    consumer.start()

if __name__ == '__main__':
    main()
